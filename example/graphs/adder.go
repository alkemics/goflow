// Code generated by goflow DO NOT EDIT.

// +build !codeanalysis

package graphs

import (
	"github.com/alkemics/goflow/example/nodes"
)

/*

 */
type Adder struct{}

func NewAdder() Adder {
	return Adder{}
}

func newAdder(id string) Adder {
	return Adder{}
}

/*

 */
func (g *Adder) Run(a, b int) (sum int) {
	// __adder_a outputs
	var __adder_a_aggregated int

	// __adder_b outputs
	var __adder_b_aggregated int

	// __output_sum_builder outputs
	var __output_sum_builder_sum int

	// adder outputs
	var adder_sum int

	// inputs outputs
	var inputs_a int
	var inputs_b int

	igniteNodeID := "ignite"
	doneNodeID := "done"

	done := make(chan string)
	defer close(done)

	steps := map[string]struct {
		deps        map[string]struct{}
		run         func()
		alreadyDone bool
	}{

		"__adder_a": {
			deps: map[string]struct{}{
				"inputs":     {},
				igniteNodeID: {},
			},
			run: func() {
				__adder_a_aggregated = inputs_a
				done <- "__adder_a"
			},
			alreadyDone: false,
		},
		"__adder_b": {
			deps: map[string]struct{}{
				"inputs":     {},
				igniteNodeID: {},
			},
			run: func() {
				__adder_b_aggregated = inputs_b
				done <- "__adder_b"
			},
			alreadyDone: false,
		},
		"__output_sum_builder": {
			deps: map[string]struct{}{
				"adder":      {},
				igniteNodeID: {},
			},
			run: func() {
				__output_sum_builder_sum = adder_sum
				sum = __output_sum_builder_sum
				done <- "__output_sum_builder"
			},
			alreadyDone: false,
		},
		"adder": {
			deps: map[string]struct{}{
				"__adder_a":  {},
				"__adder_b":  {},
				igniteNodeID: {},
			},
			run: func() {
				adder_sum = nodes.Adder(__adder_a_aggregated, __adder_b_aggregated)
				done <- "adder"
			},
			alreadyDone: false,
		},
		"inputs": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				inputs_a = a
				inputs_b = b
				done <- "inputs"
			},
			alreadyDone: false,
		},
		igniteNodeID: {
			deps: map[string]struct{}{},
			run: func() {
				done <- igniteNodeID
			},
			alreadyDone: false,
		},
		doneNodeID: {
			deps: map[string]struct{}{
				"__adder_a":            {},
				"__adder_b":            {},
				"__output_sum_builder": {},
				"adder":                {},
				"inputs":               {},
			},
			run: func() {
				done <- doneNodeID
			},
			alreadyDone: false,
		},
	}

	// Ignite
	ignite := steps[igniteNodeID]
	ignite.alreadyDone = true
	steps[igniteNodeID] = ignite
	go steps[igniteNodeID].run()

	// Resolve the graph
	for resolved := range done {
		if resolved == doneNodeID {
			// If all the graph was resolved, get out of the loop
			break
		}

		for name, step := range steps {
			delete(step.deps, resolved)
			if len(step.deps) == 0 && !step.alreadyDone {
				step.alreadyDone = true
				steps[name] = step
				go step.run()
			}
		}
	}

	return sum
}

// MarshalJSON returns the json representation of the graphs. It is pre-generated by
// WithJSONMarshal, and hence never returns an error.
func (g Adder) MarshalJSON() ([]byte, error) {
	return []byte("{\"doc\":\"\",\"edges\":[{\"sourceId\":\"adder\",\"targetId\":\"outputs\",\"inputType\":\"whatever\"},{\"sourceId\":\"inputs\",\"targetId\":\"adder\",\"inputType\":\"int\"},{\"sourceId\":\"inputs\",\"targetId\":\"adder\",\"inputType\":\"int\"}],\"filename\":\"graphs/adder.yml\",\"id\":\"Adder\",\"inputs\":[{\"name\":\"a\",\"type\":\"int\"},{\"name\":\"b\",\"type\":\"int\"}],\"nodes\":[{\"id\":\"adder\",\"pkg\":\"nodes\",\"type\":\"Adder\",\"inputs\":[{\"name\":\"a\",\"type\":\"int\"},{\"name\":\"b\",\"type\":\"int\"}],\"outputs\":[{\"name\":\"sum\",\"type\":\"int\"}],\"dependencies\":null}],\"outputs\":[{\"name\":\"sum\",\"type\":\"int\"}],\"pkg\":\"graphs\",\"type\":\"Adder\"}"), nil
}
